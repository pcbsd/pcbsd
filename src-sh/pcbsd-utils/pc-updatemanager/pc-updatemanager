#!/bin/sh
# Script which performs updating services
############################################################################

# Source our functions
. /usr/local/share/pcbsd/scripts/functions.sh

# Set the program location
PROGDIR="/usr/local/share/pcbsd/pc-updatemanager" ; export PROGDIR

# Start by sourcing /etc/profile
# This grabs any HTTP_ / FTP_ PROXY variables
. /etc/profile

PCBSD_ETCCONF="/usr/local/etc/pcbsd.conf"
export PCBSD_ETCCONF

# Set the pub openssl key
SKEY="${PROGDIR}/conf/security.key" ; export SKEY

# Directory to store downloaded updates
DOWNLOADDIR="/usr/local/tmp"

# Get the system version we are checking for updates to
SYSVER="`uname -r | cut -d '-' -f 1-2`" ; export SYSVER

# Get the system type
SYSTYPE="`/usr/local/bin/pbreg get /PC-BSD/SysType`" ; export SYSTYPE

# Set the config location
UPDATECONF="${PROGDIR}/conf/sysupdate.conf"

# Set the system arch type
ARCH=`uname -m`

# Patchset Data
PATCHSERVER="`cat ${UPDATECONF} | grep '^UPDATESERVER:' | cut -d ' ' -f 2`"
PATCHSET="`cat ${UPDATECONF} | grep '^PATCHSET:' | cut -d ' ' -f 2`"
PATCHFILE="${PATCHSET}.upd"
PATCHURL="${PATCHSERVER}/${PATCHFILE}"
PATCHTMPDIR=`mktemp -d /tmp/.sysupdateXXXXXX`
PATCHTMPFILE="${PATCHTMPDIR}/sysupdate-${SYSVER}.upd"

MUSTAGEDIR="${DOWNLOADDIR}/update-stagedir"

# Enable ftp passive mode for file transfers
FTP_PASSIVE_MODE="YES" ; export FTP_PASSIVE_MODE

if [ ! -d "${DOWNLOADDIR}" ]; then mkdir -p ${DOWNLOADDIR}; fi


# Trigger File for Tray Application
TRIGGERFILE="/tmp/.sysupdatetraytrigger"

DBDIR="/var/db/pc-updatemanager"
INSDIR="${DBDIR}/installed"
IGNDIR="${DBDIR}/ignored"

# PKG_CMD to use
PKG_CMD="/usr/sbin/pkg"

# Make sure we don't keep these from system environment
unset INJAIL PKG_FLAG

ISOTMP="/usr/local/tmp/pcbsd-update.iso"

# The default log file for output messages
LOGOUT="/var/log/pc-updatemanager.log"

# Return codes
PKGUPDATERTN=100
FBSDUPDATEONLYRTN=150
FBSDMAJORONLYRTN=151
FBSDUPDATEPLUSMAJORRTN=152
UPDATEOTHERRTN=125

######################################################################
# Done with config values
######################################################################

# Get the PACKAGE_SET to use for this pkgng repo
PACKAGE_SET="PRODUCTION"
_pkgChk="`sed -n 's/PACKAGE_SET: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_pkgChk}" ] ; then PACKAGE_SET="$_pkgChk" ; fi

AUTO_UPDATE="securitypkg"
_upChk="`sed -n 's/AUTO_UPDATE: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_upChk}" ] ; then AUTO_UPDATE="$_upChk" ; fi

# Check the PACKAGE_SET variable
case $PACKAGE_SET in
   PRODUCTION|EDGE) ;;
  CUSTOM) # Using a custom package set?
          # Lets check that we have a URL provided
	  _urlChk="`sed -n 's/^PACKAGE_URL: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
	  if [ -z "${_urlChk}" ] ; then
	     echo "Warning: PACKAGE_SET is CUSTOM, but no PACKAGE_URL set!"
	     echo "Reverting back to PRODUCTION repo..."
	     sleep 3
             CUSTOM_URL=""
	     PACKAGE_SET="PRODUCTION"
	  else
	     CUSTOM_URL="$_urlChk"
          fi
	  _urlChk="`sed -n 's/^CURSYS_PACKAGE_URL: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
	  if [ -z "${_urlChk}" ] ; then
             CUSTOM_CURSYS_URL=""
	  else
	     CUSTOM_CURSYS_URL="$_urlChk"
          fi
          ;;
       *) echo "Warning: Invalid PACKAGE_SET!" 
          PACKAGE_SET="PRODUCTION" ;; 
esac

show_usage() {
        echo "pc-updatemanager: Usage
----
  branches 		- List available system branches
  chbranch <tag> 	- Change to new system branch
  check 		- Check for system updates
  install <tag>,<tag2> 	- Install system updates
  pkgcheck 		- Check for updates to packages
  pkgupdate 		- Install packages updates
  fbsdupdate		- Install freebsd-update patches
  fbsdupdatepkgs	- Install freebsd-update patches and any package updates
  syncconf		- Update PC-BSD pkgng configuration
  confcheck		- Check PC-BSD pkgng configuration
  cron                  - Perform delayed check for system and pkgng updates.
"	

	exit 1
}

echo_log()
{
   echo "$@"
   echo "$@" >> ${LOGOUT}
}

setup_pkgng_conf() {

  # See if we need to adjust pcbsd.conf repo file
  if [ ! -e "/usr/local/etc/pkg/repos/pcbsd.conf.dist" ];then
     echo "WARNING: Missing /usr/local/etc/pkg/repos/pcbsd.conf.dist"
     status="1"
     return 1
  fi

  # Remove old pkg conf
  if [ -e "/usr/local/etc/pkg/repos/pcbsd.conf" ] ; then
    rm /usr/local/etc/pkg/repos/pcbsd.conf
  fi

  ARCH=`uname -m`
  FBSDVER=`uname -r | cut -d '-' -f 1-2`
  MAJORVER="`uname -r | cut -d '-' -f 1 |  cut -d '.' -f 1`.0-RELEASE"

  # Make sure we are on a -RELEASE, otherwise use the proper uname
  echo $FBSDVER | grep -q -e 'RELEASE' -e 'STABLE'
  if [ $? -ne 0 ] ; then MAJORVER="$FBSDVER"; fi

  # If using the EDGE package set, set the right path
  case $PACKAGE_SET in
       EDGE) FBSDVER="$FBSDVER/edge"
	     MAJORVER="$MAJORVER/edge"
	     ;;
          *) ;;
  esac

  # Now create standard pcbsd.conf file
  if [ "$PACKAGE_SET" = "CUSTOM" -a -n "$CUSTOM_URL" ] ; then
     # Change %VERSION% / %ARCH% keys
     CUSTOM_URL=`echo $CUSTOM_URL | sed "s|%VERSION%|$MAJORVER|g" | sed "s|%ARCH%|$ARCH|g"`
     cat << EOF >/usr/local/etc/pkg/repos/pcbsd.conf
pcbsd-major: {
               url: "$CUSTOM_URL",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/pcbsd",
               enabled: true
              }
EOF
  else
     # Using PC-BSD CDN
     cat /usr/local/etc/pkg/repos/pcbsd.conf.dist \
	| sed "s|pcbsd: |pcbsd-major: |g" \
	| sed "s|%VERSION%|$MAJORVER|g" \
	| sed "s|%ARCH%|$ARCH|g" \
	| sed "s|VERSION|$MAJORVER|g" \
	| sed "s|ARCH|$ARCH|g" > /usr/local/etc/pkg/repos/pcbsd.conf
  fi

  if [ -e "/usr/local/etc/pkg/repos/01pcbsd.conf" ] ; then
     rm /usr/local/etc/pkg/repos/local-pcbsd.conf >/dev/null 2>/dev/null #eventually remove
     rm /usr/local/etc/pkg/repos/01pcbsd.conf
  fi
}

get_update_file() {

  # Now fetch the update file
  get_file "${PATCHURL}" "${PATCHTMPFILE}" 1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE} 2>/dev/null
     is_net_up
     if [ $? -eq 0 ] ; then 
       echo "No updates available for $SYSVER!" ; exit 0 
     else
       exit_err "Could not contact update server!"
     fi
  fi

  # Now fetch the update file signature
  get_file "${PATCHURL}.sha1" "${PATCHTMPFILE}.sha1" 1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE}.sha1 2>/dev/null
     is_net_up
     if [ $? -eq 0 ] ; then 
       echo "No updates available for $SYSVER!" ; exit 0 
     else
       exit_err "Could not contact update server!"
     fi
  fi

  # Lets verify the signature of the file
  openssl dgst -sha1 -verify ${SKEY} \
	-signature ${PATCHTMPFILE}.sha1 \
        ${PATCHTMPFILE} >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE} 2>/dev/null
     rm ${PATCHTMPFILE}.sha1 2>/dev/null
     exit_err "Update file failed verification..."
  fi

  # Done with the signature we can discard
  rm ${PATCHTMPFILE}.sha1

}

do_branch() {
  up="$1"

  # Setup our variable to catch if we have a bad branch
  BRANCHFOUND="0" 

  while read line
  do
     echo $line | grep -q "^BRANCHES:"
     if [ $? -eq 0 ] ; then
	for i in `echo $line | cut -d ':' -f 2 | sed 's|,| |g'`
	do
  	  if [ "$i" != "$up" ] ; then continue ;fi
  	  if [ "`uname -r | cut -d '-' -f 1-2`" = "$up" ] ; then 
	     echo "You are already on this branch!"
             BRANCHFOUND="1"
	     continue;
	  fi
          update_world_and_pkgs "$up"
          BRANCHFOUND="1"
	  break
	done
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${BRANCHFOUND}" = "0" ]; then 
     # No available updates
     echo "Unknown branch ${1}"
  fi

  rm ${PATCHTMPFILE}

};

list_branches() {
  # Setup our variable, we have no branches so far
  BRANCHFOUND="0" 

  while read line
  do
     echo $line | grep -q "^BRANCHES:"
     if [ $? -eq 0 ] ; then
	echo "Available branches:"
	echo "* = Current Branch"
        echo "----------------------------------"
	echo $line | cut -d ':' -f 2 | sed 's|,|\
|g' | while read branch
	do
		if [ "`uname -r | cut -d '-' -f 1-2`" = "$branch" ] ; then
			echo "$branch *"
		else
			echo "$branch"
		fi
	done
	echo ""
	echo "To change branches run: ${0} chbranch <branch>"
        BRANCHFOUND="1"
        continue
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${BRANCHFOUND}" = "0" ]; then 
     # No available updates
     echo "No branches currently available!"
  fi

  rm ${PATCHTMPFILE}

};

do_fbsdcheck() {
  # Setup our variable, we have no patches so far
  PATCHFOUND="0" 
  echo "Checking for FreeBSD updates..."
  if [ "`id -u`" = "0" ] ; then
    pc-fbsdupdatecheck | grep -q "will be updated"
    if [ $? -eq 0 ] ; then
       PATCHFOUND="1"
    fi
  else
    sudo /usr/local/bin/pc-fbsdupdatecheck | grep -q "will be updated"
    if [ $? -eq 0 ] ; then
       PATCHFOUND="1"
    fi
  fi

  if [ "${PATCHFOUND}" = "1" ]; then
    echo "The following updates are available:"
    echo "------------------------------------"
    echo "NAME: FreeBSD system update"
    echo "TYPE: System Update"
    echo " "
    echo "To install: \"pc-updatemanager fbsdupdate\""
    echo " "

    if [ -e "/usr/local/bin/pc-systemflag" ]; then
      pc-systemflag SYSUPDATE UPDATE #set the system flag that system updates are available
    fi
    HAVEFREEBSDUPDATES="YES"
  fi
}

do_check() {

  while read line
  do
     echo $line | grep -q "^MAJOR:"
     if [ $? -eq 0 ] ; then
        parse_mu_update_line "$line"
        continue
     fi
     echo $line | grep -q "^SA:"
     if [ $? -eq 0 ] ; then
        parse_sa_update_line "$line"
        continue
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${PATCHFOUND}" = "0" ]; then 
     # No available updates
     echo "Your system is up to date!"
     if [ -e "/usr/local/bin/pc-systemflag" ]; then
       pc-systemflag SYSUPDATE SUCCESS #set the system flag that system is up to date
     fi
     rm ${PATCHTMPFILE}
     return 0
  fi

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag SYSUPDATE UPDATE #set the system flag that system updates are available
  fi
  rm ${PATCHTMPFILE}

  if [ -n "$HAVEFREEBSDUPDATES" -a -n "$HAVEMAJORUPDATES" ] ; then
     return $FBSDUPDATEPLUSMAJORRTN
  fi
  if [ -n "$HAVEFREEBSDUPDATES" ] ; then
     return $FBSDUPDATEONLYRTN
  fi
  if [ -n "$HAVEMAJORUPDATES" ] ; then
     return $FBSDMAJORONLYRTN
  fi

  # Other updates
  return $UPDATEOTHERRTN
};

parse_mu_update_line()
{
   local line="$1"

   # Check if this is a major update we can install
   local sysUpOVer=`echo $line | cut -d ':' -f 2`
   local sysUpNVer=`echo $line | cut -d ':' -f 3`

   # Is this an update for our version?
   if [ "$SYSVER" != "$sysUpOVer" ] ; then return; fi

   if [ $PATCHFOUND -eq 0 ] ; then
      echo ""
      echo "The following updates are available:"
      echo "------------------------------------"
   fi
   echo "NAME: System Update to ${sysUpNVer}" 
   echo "TYPE: SYSUPDATE" 
   echo "TAG: fbsd-${sysUpNVer}"
   echo "VERSION: ${sysUpNVer}" 
   echo ""
   echo "To install: \"pc-updatemanager install fbsd-${sysUpNVer}\""
   echo ""
   echo ""

   PATCHFOUND="`expr ${PATCHFOUND} + 1`" 
   HAVEMAJORUPDATE="YES"
}

parse_sa_update_line()
{
   local line="$1"

   # Check if this is an update we can install
   local saVer=`echo $line | cut -d ':' -f 2`
   local saArch=`echo $line | cut -d ':' -f 3`
   local saType=`echo $line | cut -d ':' -f 4`
   local saIdent="`echo $line | cut -d ':' -f 5`"

   # For this version?
   if [ "$SYSVER" != "$saVer" ] ; then return ; fi

   # For this system arch?
   if [ "$ARCH" != "$saArch" -a "$saArch" != "noarch" ] ; then return ; fi

   # For this system type?
   if [ "$SYSTYPE" != "$saType" -a "$saType" != "both" ] ; then return ; fi

   # Already installed?
   if [ -e "${INSDIR}/${SYSVER}/$saIdent" ] ; then return ; fi

   if [ $PATCHFOUND -eq 0 ] ; then
      echo ""
      echo "The following updates are available:"
      echo "------------------------------------"
   fi
   local saDesc="`echo $line | cut -d ':' -f 6`"
   local saSize=`echo $line | cut -d ':' -f 8`
   local saDetail="http://wiki.pcbsd.org`echo $line | cut -d ':' -f 10`"
   local saDate="`echo $line | cut -d ':' -f 11`"

   echo "NAME: ${saDesc}" 
   echo "TYPE: PATCH" 
   echo "TAG: ${saIdent}"
   echo "DETAILS: ${saDetail}"
   echo "DATE: ${saDate}"
   echo "SIZE: ${saSize}Mb" 
   echo " "
   echo "To install: \"pc-updatemanager install ${saIdent}\""
   echo " "

   PATCHFOUND="`expr ${PATCHFOUND} + 1`" 
}

start_pcbsd_patch() {
  local up="$1"
  local saIdent=""
  local saVer=""
  local saArch=""
  local saPlat=""
  local saUrl=""
  local saDesc=""
  local saCsum=""
  local patchLine=""
  if [ -e "${INSDIR}/${SYSVER}/${up}" ]; then 
     rm ${PATCHTMPFILE}
     exit_err "Patch $up already installed!"
  fi

  while read line
  do
    echo $line | grep -q "^SA:"
    if [ $? -ne 0 ] ; then continue; fi
    saIdent="`echo $line | cut -d ':' -f 5`"
    # Look for the right stand-alone update
    if [ "$saIdent" != "$up" ] ; then continue ; fi
    saVer=`echo $line | cut -d ':' -f 2`
    saArch=`echo $line | cut -d ':' -f 3`
    saType=`echo $line | cut -d ':' -f 4`
    # Does this update apply to this system arch?
    if [ "$saArch" != "$ARCH" -a "$saArch" != "noarch" ] ; then 
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system arch type!"
    fi
    # For this version?
    if [ "$saVer" != "$SYSVER" ] ; then 
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system version!"
    fi

    # For this system type?
    if [ "$SYSTYPE" != "$saType" -a "$saType" != "both" ] ; then
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system type!"
    fi

    # Got here? We have a patch ready to go
    patchLine="$line"
    break
  done < ${PATCHTMPFILE}

  # Did we find the patch?
  if [ -z "$patchLine" ] ; then 
     rm ${PATCHTMPFILE}
     exit_err "Patch $up not found!"
  fi

  # Get the patch details
  saVer=`echo $patchLine | cut -d ':' -f 2`
  saArch=`echo $patchLine | cut -d ':' -f 3`
  saPlat=`echo $patchLine | cut -d ':' -f 4`
  saIdent="`echo $patchLine | cut -d ':' -f 5`"
  saDesc="`echo $patchLine | cut -d ':' -f 6`"
  saUrl="`echo $patchLine | cut -d ':' -f 7`"
  saCsum="`echo $patchLine | cut -d ':' -f 9`"
  local FILENAME="`basename $saUrl`"

  # Start downloading the patch
  touch ${TRIGGERFILE}
  echo "DOWNLOADING: ${saIdent}"
  echo "DOWNLOADING: ${saIdent}" >${TRIGGERFILE}

  # Get the file
  get_file_from_mirrors "/${saUrl}" "${DOWNLOADDIR}/${FILENAME}" "update"
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE}
     echo "FAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "Failed to download: ${saIdent}"
  fi

  # Check the sha256 checksum
  if [ "$saCsum" != "`sha256 -q ${DOWNLOADDIR}/${FILENAME} 2>/dev/null`" ]
  then
     # Download MD5 doesn't match! Delete the file
     rm ${PATCHTMPFILE}
     rm ${DOWNLOADDIR}/${FILENAME}
     echo "FAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "Failed to download: ${saIdent}"
  else 
     echo "DOWNLOADFINISHED: ${saIdent}"
     echo "DOWNLOADFINISHED: ${saIdent}" >${TRIGGERFILE}
  fi

  echo "INSTALLING: ${saIdent}" >${TRIGGERFILE}
  sleep 1

  # Lets auto-create a new boot-environment before updating
  create_auto_beadm

  PATCHTMPDIR="`mktemp -d ${DOWNLOADDIR}/patchInstallXXXXX`"
  rc_halt "tar xvJf ${DOWNLOADDIR}/${FILENAME} -C ${PATCHTMPDIR}" 2>/dev/null
  PATCHDIR="$PATCHTMPDIR" ; export PATCHDIR
  cd ${PATCHTMPDIR}
  sh update.sh
  if [ $? -eq 0 ]; then
     touch "${INSDIR}/${SYSVER}/${saIdent}"
     echo "INSTALLFINISHED: ${saIdent}"
     echo "INSTALLFINISHED: ${saIdent}" >${TRIGGERFILE}
  else
     rm ${PATCHTMPFILE}
     rm -rf ${PATCHTMPDIR}
     rm ${DOWNLOADDIR}/${FILENAME}
     echo "INSTALLFAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "INSTALLFAILED: ${saIdent}"
  fi

  rc_halt "rm -rf ${PATCHTMPDIR}"
  rc_halt "rm ${DOWNLOADDIR}/${FILENAME}"
}

do_install() {
	if [ -z "$1" ] ; then exit_err "No updates specified to install!"; fi

	if [ -e "/usr/local/bin/pc-systemflag" ]; then
	  pc-systemflag SYSUPDATE UPDATING #set the flag that system is updating
	fi
	# Begin to update the selected items
	for up in `echo $1 | sed 's|,| |g'`
	do
	  # If this is a major update, start it up!
  	  echo $up | grep -q "^fbsd-" 
	  if [ $? -eq 0 ] ; then 
            update_world_and_pkgs "`echo $up | sed 's|fbsd-||g'`"
	    exit 0
          else
	    # Doing regular pcbsd patch
	    start_pcbsd_patch "${up}"
            continue
          fi
	done 
	if [ -e "/usr/local/bin/pc-systemflag" ]; then
	  pc-systemflag SYSUPDATE SUCCESS #set the flag that system updates finished
	fi
        # All Finished!
        rm ${PATCHTMPFILE}
        exit 0
}

is_net_up() {
	ping -c 1 www.pcbsd.org >/dev/null 2>/dev/null
	ret=$?
	if [ $ret -ne 0 ]; then
	  if [ -e "/usr/local/bin/pc-systemflag" ]; then
	    pc-systemflag NETRESTART ERROR #set the system flag that no internet available
	  fi
	fi
	return $ret
}

sync_pkgconf() {
  # Update systems pkgng configuration
  setup_pkgng_conf
}

check_pkgconf() {

  # Update systems pkgng configuration
  setup_pkgng_conf
  exit $?
}

checkup_pkgs() {

  # Update the repo DB
  if [ "`id -u`" = "0" ] ; then
    rc_halt "${PKG_CMD} update"
  fi

  ${PKG_CMD} ${PKG_FLAG} upgrade -n >/tmp/.pkgData.$$
  if [ $? -ne 0 ] ; then
     echo "Error checking for package updates..."
     if [ -e "/usr/local/bin/pc-systemflag" ]; then
       pc-systemflag PKGUPDATE ERROR #set the system flag pkg check errored
     fi
     exit 1
  fi

  # Check for updates now
  grep -q "Your packages are up to date" /tmp/.pkgData.$$
  if [ $? -eq 0 ] ; then
     echo "All packages are up to date!"
     if [ -e "/usr/local/bin/pc-systemflag" ]; then
       pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
     fi
     rm /tmp/.pkgData.$$
     return 0
  fi

  # Display the pkg update data
  cat /tmp/.pkgData.$$
  rm /tmp/.pkgData.$$
  echo ""
  echo "To install: \"pc-updatemanager pkgupdate\""
  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATE #set the system flag that updates available
  fi
  return $PKGUPDATERTN
}

set_update_vars()
{
  unset EVENT_PIPE

  # Set some locations
  STAGEBE="pcupdatestage"
  STAGEMNT="/.updateStage"
  OLDPKGLIST="/tmp/.pkgUpdateList.$$"
  NEWPKGLIST="/tmp/.newPkgUpdateList.$$"
  PKGUPGRADELOG="/tmp/.pkgUpdateLog.$$"
  PKGDLCACHE="/usr/local/pkg-cache"
  touch ${PKGUPGRADELOG}

}

update_freebsd()
{
  touch_updateinprogress

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi

  # Check if user requested to do updates + pkgs
  doPkgUpdates="NO"
  if [ "$1" = "pkgs" ] ; then
    doPkgUpdates="YES"
  fi

  # First lets see if we have packages to update at the same time
  ${PKG_CMD} ${PKG_FLAG} upgrade -n >/tmp/.pkgData.$$
  grep -q "Your packages are up to date" /tmp/.pkgData.$$
  if [ $? -eq 0 ] ; then doPkgUpdates="NO"; fi
  rm /tmp/.pkgData.$$

  set_update_vars

  kill_syscache

  if [ "$doPkgUpdates" = "YES" ] ; then
    mk_pkg_conf
    build_pkg_list
    dl_pkgs
  fi

  mk_stage_be
  mount_stage_be

  run_freebsd_update_script

  if [ "$doPkgUpdates" = "YES" ] ; then
    prep_pkgs_chroot
    install_pkgs_chroot
  fi

  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  start_syscache

  touch_reboot
  echo_log "Your update is finished! Please reboot to load into the new boot-environment"
  exit 0
}

update_pkgs_only()
{
  touch_updateinprogress

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi

  set_update_vars

  kill_syscache
  mk_pkg_conf
  build_pkg_list
  dl_pkgs
  mk_stage_be
  mount_stage_be
  prep_pkgs_chroot
  install_pkgs_chroot
  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  start_syscache

  touch_reboot
  echo_log "Your update is finished! Please reboot to load into the new boot-environment"
  exit 0
}

update_world_and_pkgs()
{
  # Set the new version of FreeBSD we are installing
  NEWFREEBSDVERSION="$1"

  touch_updateinprogress

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi

  set_update_vars

  kill_syscache
  mk_pkg_conf
  build_pkg_list
  dl_pkgs
  mk_stage_be
  mount_stage_be
  prep_pkgs_chroot
  prep_rc_script
  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  start_syscache

  touch_reboot
  echo_log "Update stage one is finished! Please reboot to start stage 2."

  exit 0
}

start_syscache()
{
  if [ -e "/usr/local/etc/rc.d/syscache" ] ; then
     echo_log "Starting syscache..."
     /usr/local/etc/rc.d/syscache start >/dev/null 2>/dev/null
  fi
}

kill_syscache()
{
  if [ -e "/usr/local/etc/rc.d/syscache" ] ; then
     echo_log "Stopping syscache..."
     /usr/local/etc/rc.d/syscache stop >/dev/null 2>/dev/null
  fi
}

mk_pkg_conf()
{
   PKG_FLAG=""
   PKG_CFLAG=""

   if [ ! -d "$PKGDLCACHE" ] ; then
     mkdir -p $PKGDLCACHE
   fi

   # Get rid of FreeBSD.conf repo
   if [ -e "/etc/pkg/FreeBSD.conf" ] ; then
      rm /etc/pkg/FreeBSD.conf
   fi

   # Set the cache directory
   PKG_CFLAG="-C /tmp/.pkgUpdate.conf"
   echo "PKG_CACHEDIR: $PKGDLCACHE" > /tmp/.pkgUpdate.conf

   # If doing a major update also, add the new repos config
   if [ -n "$NEWFREEBSDVERSION" ] ; then
      setup_pkgng_newrepo_conf
   fi
}

setup_pkgng_newrepo_conf() {

  # Lets create a new repo file to match the version of BSD we are upgrading to

  # See if we need to adjust pcbsd.conf repo file
  if [ ! -e "/usr/local/etc/pkg/repos/pcbsd.conf.dist" ];then
     echo_log "ERROR: Missing /usr/local/etc/pkg/repos/pcbsd.conf.dist"
     exit 1
  fi

  ARCH=`uname -m`
  FBSDVER="$NEWFREEBSDVERSION"
  MAJORVER="`echo $FBSDVER | cut -d '-' -f 1 |  cut -d '.' -f 1`.0-RELEASE"

  # Make sure we are on a -RELEASE or -STABLE, otherwise use the proper uname
  echo $FBSDVER | grep -q -e 'RELEASE' -e 'STABLE'
  if [ $? -ne 0 ] ; then MAJORVER="$FBSDVER"; fi

  # If using the EDGE package set, set the right path
  case $PACKAGE_SET in
       EDGE) FBSDVER="$FBSDVER/edge"
	     MAJORVER="$MAJORVER/edge"
	     ;;
          *) ;;
  esac

  rm -rf /tmp/.updateRepo >/dev/null 2>/dev/null
  mkdir /tmp/.updateRepo

  # Now create standard pcbsd.conf file
  if [ "$PACKAGE_SET" = "CUSTOM" -a -n "$CUSTOM_URL" ] ; then
     # Change %VERSION% / %ARCH% keys
     CUSTOM_URL=`echo $CUSTOM_URL | sed "s|%VERSION%|$MAJORVER|g" | sed "s|%ARCH%|$ARCH|g"`
     cat << EOF >/tmp/.updateRepo/pkgUpdateRepo.conf
pcbsd-major: {
               url: "$CUSTOM_URL",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/pcbsd",
               enabled: true
              }
EOF
  else
    # Using PC-BSD CDN
    cat /usr/local/etc/pkg/repos/pcbsd.conf.dist \
      | sed "s|pcbsd: |pcbsd-major: |g" \
      | sed "s|%VERSION%|$MAJORVER|g" \
      | sed "s|%ARCH%|$ARCH|g" \
      | sed "s|VERSION|$MAJORVER|g" \
      | sed "s|ARCH|$ARCH|g" > /tmp/.updateRepo/pkgUpdateRepo.conf
  fi

  # Set the new PKG_FLAG to use this repo config
  PKG_FLAG="-R /tmp/.updateRepo"
}

build_pkg_list()
{
  # Figure out which base to install
  pkg info -e pcbsd-base
  if [ $? -eq 0 -o -e "/etc/defaults/pcbsd" ] ; then
     SYSBASE="misc/pcbsd-base"
  else
     SYSBASE="misc/trueos-base"
  fi
  SYSBASEFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery '%n-%v' $SYSBASE 2>/dev/null | head -n 1`.txz"

  # Build top-level list of pkgs installed
  ${PKG_CMD} query -e '%#r=0' '%o %n-%v' | sort | grep -v 'ports-mgmt/pkg ' | grep -v 'misc/pcbsd-base ' | grep -v 'misc/trueos-base ' > $OLDPKGLIST

  echo "Original top-level packages:" > $PKGUPGRADELOG
  echo "-----------------------------------------------" >> $PKGUPGRADELOG
  cat $OLDPKGLIST >> $PKGUPGRADELOG
  echo "-----------------------------------------------" >> $PKGUPGRADELOG
}

dl_pkgs()
{
  # Update the DB first
  echo_log "Updating the package repo database..."
  ${PKG_CMD} ${PKG_FLAG} update -f >/dev/null 2>/dev/null

  # Clean pkgs
  echo_log "Cleaning old pkg upgrade cache..."
  ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} clean -y >/dev/null 2>/dev/null

  if [ -e "$NEWPKGLIST" ] ; then rm $NEWPKGLIST; fi

  # Save the PKGNG filename
  PKGFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' ports-mgmt/pkg 2>/dev/null | head -n 1`.txz"

  # First off, fetch the pkgng pkg
  echo_log "Fetching packages for ports-mgmt/pkg - $PKGFILENAME"
  echo "Fetching packages for ports-mgmt/pkg - $PKGFILENAME" >> ${PKGUPGRADELOG}
  ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y ports-mgmt/pkg >/tmp/.pkgOut.$$ 2>/tmp/.pkgOut.$$
  if [ $? -ne 0 ] ; then
     cat /tmp/.pkgOut.$$
     cat /tmp/.pkgOut.$$ >> $LOGOUT
     cat /tmp/.pkgOut.$$ >> $PKGUPGRADELOG
     exit_err "Failed fetching: ports-mgmt/pkg - $PKGFILENAME"
  fi

  REALPKGDLCACHE="${PKGDLCACHE}"
  # PKGNG lies, we need to verify if the package was really downloaded
  if [ ! -e "${PKGDLCACHE}/${PKGFILENAME}" ] ; then
     # Also check All/ since pkg docs are rather unclear about if that will be used or not
     if [ -e "${PKGDLCACHE}/All/${PKGFILENAME}" ] ; then
        REALPKGDLCACHE="${PKGDLCACHE}/All"
     else
        exit_err "Failed downloading ports-mgmt/pkg with: $PKG_CMD $PKG_FLAG fetch -d -y ports-mgmt/pkg"
     fi
  fi



  # Fetch the SYSBASE packages, halt if this fails
  SYSBASEFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' $SYSBASE 2>/dev/null | head -n 1`.txz"
  echo_log "Fetching packages for ${SYSBASE} - $SYSBASEFILENAME"
  echo "Fetching packages for ${SYSBASE} - $SYSBASEFILENAME" >> ${PKGUPGRADELOG}
  ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y ${SYSBASE} >/tmp/.pkgOut.$$ 2>/tmp/.pkgOut.$$
  if [ $? -ne 0 ] ; then
     cat /tmp/.pkgOut.$$
     cat /tmp/.pkgOut.$$ >> $LOGOUT
     cat /tmp/.pkgOut.$$ >> $PKGUPGRADELOG
     exit_err "Failed fetching: $SYSBASE - $SYSBASEFILENAME"
  fi

  # PKGNG lies, we need to verify if the package was really downloaded
  if [ ! -e "${REALPKGDLCACHE}/${SYSBASEFILENAME}" ] ; then
     exit_err "Failed downloading $SYSBASE with: $PKG_CMD $PKG_FLAG fetch -d -y $SYSBASE"
  fi



  # Now start fetching all the update packages
  while read pkgLine
  do
    pkgOrigin="`echo $pkgLine | cut -d ' ' -f 1`"
    pkgName="`echo $pkgLine | cut -d ' ' -f 2`"

    # Check if this pkg exists in the new repo
    unset FETCHFILENAME
    FETCHFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' $pkgOrigin 2>/dev/null | head -n 1`"
    if [ -z "$FETCHFILENAME" ] ; then
       echo_log "*****"
       echo_log "No such package in new repo: $pkgOrigin"
       echo "*****" >> $PKGUPGRADELOG
       echo "No such package in new repo: $pkgOrigin" >> $PKGUPGRADELOG
       echo "*****" >> $LOGOUT
       echo "*****" >> $PKGUPGRADELOG
       continue
    fi
    FETCHFILENAME="${FETCHFILENAME}.txz"

    # Fetch the pkg now
    echo_log "Fetching packages for ${pkgOrigin} - $FETCHFILENAME"
    echo "Fetching packages for ${pkgOrigin} - $FETCHFILENAME" >> ${PKGUPGRADELOG}
    ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y $pkgOrigin >/tmp/.pkgOut.$$ 2>/tmp/.pkgOut.$$
    if [ $? -ne 0 ] ; then
       echo_log "*****" >> $PKGUPGRADELOG
       echo_log "Failed fetching: $pkgOrigin"
       cat /tmp/.pkgOut.$$
       cat /tmp/.pkgOut.$$ >> $LOGOUT
       echo_log "*****"

       echo "*****" >> $PKGUPGRADELOG
       echo "Failed fetching: $pkgOrigin" >> $PKGUPGRADELOG
       cat /tmp/.pkgOut.$$ >> $PKGUPGRADELOG
       echo "*****" >> $PKGUPGRADELOG
    fi

    # PKGNG lies, we need to verify if the package was really downloaded
    if [ ! -e "${REALPKGDLCACHE}/${FETCHFILENAME}" ] ; then
       echo_log "*****"
       echo_log "Failed fetching: $pkgOrigin - $FETCHFILENAME"
       cat /tmp/.pkgOut.$$
       cat /tmp/.pkgOut.$$ >> $LOGOUT
       echo_log "*****"

       echo "*****" >> $PKGUPGRADELOG
       echo "Failed fetching: $pkgOrigin - $FETCHFILENAME" >> $PKGUPGRADELOG
       cat /tmp/.pkgOut.$$ >> $PKGUPGRADELOG
       echo "*****" >> $PKGUPGRADELOG
       echo_log "Failed downloading $pkgOrigin with: $PKG_CMD $PKG_FLAG fetch -d -y $pkgOrigin"
    fi
    echo "$pkgOrigin $FETCHFILENAME" >> $NEWPKGLIST
  done < $OLDPKGLIST

  echo_log "-----------------------------------------------"
  echo "-----------------------------------------------" >> ${PKGUPGRADELOG}
}

mk_stage_be()
{
  echo_log "Creating stage BE..."
  umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
  umount -f $STAGEMNT 2>/dev/null >/dev/null

  # Auto-prune any old / stale BEs
  do_prune_be

  # Check for an existing BE for upgrades
  beadm list -H | awk '{print $1}' | grep -q "$STAGEBE"
  if [ $? -eq 0 ] ; then
     beadm destroy -F $STAGEBE
  fi

  # Create the new stage boot environment
  rc_halt "beadm create $STAGEBE" >>${LOGOUT} 2>>${LOGOUT}
}

mount_stage_be()
{
  # Get the stage mount-point ready
  echo_log "Mounting the stage BE..."
  if [ ! -d "$STAGEMNT" ] ; then mkdir -p $STAGEMNT; fi
  umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
  umount -f $STAGEMNT 2>/dev/null >/dev/null

  # Mount the BE
  rc_halt "beadm mount $STAGEBE $STAGEMNT"
  if [ "$doPkgUpdates" = "YES" ] ; then
    rc_halt "cp $NEWPKGLIST ${STAGEMNT}/install-pkg-list"
  fi
  rc_halt "mount -t devfs devfs ${STAGEMNT}/dev"
  
}

prep_pkgs_chroot()
{
  # Now start our chroot commands

  # First, clean the BE old pkgs
  echo_log "Preparing the new boot-environment... (This may take a while)"
  rc_halt "chroot ${STAGEMNT} pkg delete -ay" >>${LOGOUT} 2>>${LOGOUT}

  # Next create the script to bootstrap pkgng
  echo "#!/bin/sh
tar xvpf ${REALPKGDLCACHE}/${PKGFILENAME} -C / /usr/local/sbin/pkg-static >/dev/null 2>/dev/null
/usr/local/sbin/pkg-static add -f ${REALPKGDLCACHE}/${PKGFILENAME}
if [ \$? -ne 0 ] ; then exit 1; fi
cd ${REALPKGDLCACHE}

# Cleanup the old /compat/linux for left-overs
umount /compat/linux/proc >/dev/null 2>/dev/null
umount /compat/linux/sys >/dev/null 2>/dev/null
rm -rf /compat/linux
mkdir -p /compat/linux/proc
mkdir -p /compat/linux/sys

# Check for a new linux compat version to set
pcUtils=\`ls pcbsd-utils-[0-9]*.txz\`
if [ -n \"\$pcUtils\" ] ; then
   tar xvf \$pcUtils --strip-components=6 -C /tmp /usr/local/share/pcbsd/conf/linux-compat-version 2>/dev/null
   if [ -e \"/tmp/linux-compat-version\" ] ; then
      lVer=\`cat /tmp/linux-compat-version\`
      sysctl compat.linux.osrelease=\$lVer
   fi
fi

echo \"Installing $SYSBASEFILENAME...\"
pkg add $SYSBASEFILENAME >/pkg-add.log 2>/pkg-add.log
if [ \$? -ne 0 ] ; then exit 1; fi

while read pkgLine
do
  pkgOrigin=\"\`echo \$pkgLine | cut -d ' ' -f 1\`\"
  pkgName=\"\`echo \$pkgLine | cut -d ' ' -f 2\`\"
  if [ ! -e \"\${pkgName}\" ] ; then
     echo \"No such package: \${pkgName}\"
     echo \"No such package: \${pkgName}\" >>/removed-pkg-list
     continue
  fi

  echo \"Installing \$pkgName...\"
  pkg add \${pkgName} >/pkg-add.log 2>/pkg-add.log
  if [ \$? -ne 0 ] ; then
     echo \"Failed installing \${pkgName}\"
     cat /pkg-add.log
     echo \"Failed installing \${pkgName}\" >>/failed-pkg-list
     cat /pkg-add.log >>/failed-pkg-list
  fi
done < /install-pkg-list
rm /pkg-add.log

echo \"Extracting ports overlay...\"
/usr/local/bin/pc-extractoverlay ports
if [ \$? -ne 0 ] ; then exit 1; fi

echo \"Updating pkgng config...\"
/usr/local/bin/pc-updatemanager syncconf
if [ \$? -ne 0 ] ; then exit 1; fi

# Save the log files
if [ ! -d \"/usr/local/log/pc-updatemanager\" ] ; then
  mkdir -p /usr/local/log/pc-updatemanager
fi
touch /install-pkg-list
touch /removed-pkg-list
touch /failed-pkg-list
mv /install-pkg-list /usr/local/log/pc-updatemanager/
mv /removed-pkg-list /usr/local/log/pc-updatemanager/
mv /failed-pkg-list /usr/local/log/pc-updatemanager/

exit 0
" > ${STAGEMNT}/.doPkgUp.sh

}

install_pkgs_chroot()
{
  # Run it now
  echo_log "Installing packages to stage BE... (This may take a while)"
  rc_halt "chroot ${STAGEMNT} sh /.doPkgUp.sh" >>${LOGOUT} 2>>${LOGOUT}
  rm ${STAGEMNT}/.doPkgUp.sh
}

run_freebsd_update_script()
{
  # Start the upgrade with freebsd-update, get files downloaded installed
  echo_log "Fetching freebsd-update files..."
  rc_halt "chroot ${STAGEMNT} freebsd-update --non-interactive fetch" >>${LOGOUT} 2>${LOGOUT}
  echo_log "Installing freebsd-update files..."
  rc_halt "chroot ${STAGEMNT} freebsd-update install" >>${LOGOUT} 2>${LOGOUT}
  NEWFREEBSDVERSION="`chroot ${STAGEMNT} /bin/freebsd-version`"
}

prep_rc_script()
{
  # Start the upgrade with freebsd-update, get files downloaded and kernel installed
  rc_halt "chroot ${STAGEMNT} freebsd-update --non-interactive -r $NEWFREEBSDVERSION upgrade"
  rc_halt "chroot ${STAGEMNT} freebsd-update install"

  # Now prep the RC script to do the rest of the upgrade after reboot
  rc_halt "chroot ${STAGEMNT} mv /etc/rc /etc/rc-orig"
  rc_halt "chroot ${STAGEMNT} mkdir -p /compat/linux/proc"
  rc_halt "chroot ${STAGEMNT} mkdir -p /compat/linux/sys"
  rc_halt "cp ${PROGDIR}/rc-update ${STAGEMNT}/etc/rc"
  rc_halt "cp ${PROGDIR}/rc-update ${STAGEMNT}/etc/rc-update"
  rc_halt "cp ${PROGDIR}/rc-doupdate ${STAGEMNT}/etc/rc-doupdate"
}

umount_stage_be()
{
  echo_log "Unmounting stage BE..."
  if [ ! -d "${STAGEMNT}/usr/local/log/pc-updatemanager" ] ; then
     mkdir -p "${STAGEMNT}/usr/local/log/pc-updatemanager"
  fi
  rc_halt "cp ${PKGUPGRADELOG} ${STAGEMNT}/usr/local/log/pc-updatemanager/upgrade.log"

  # Now cleanup / unmount
  rc_halt "umount -f ${STAGEMNT}/dev"
  rc_halt "beadm umount -f ${STAGEBE}"
}

mk_stage_be_default()
{
  nDate=`date "+%Y%m%d_%H%M%S"`
  if [ -n "$NEWFREEBSDVERSION" ] ; then
    beName="${NEWFREEBSDVERSION}-up-${nDate}"
  else
    beName="`uname -r`-up-${nDate}"
  fi
  rc_halt "beadm rename $STAGEBE $beName"
  rc_halt "beadm activate $beName"
  rc_halt "grub-mkconfig -o /boot/grub/grub.cfg"
}

do_auto_be()
{
  # User requested a new autobe to be created
  create_auto_beadm
}

touch_updateinprogress()
{
   if [ -e "/tmp/.rebootRequired" ] ; then
      exit_err "Waiting to reboot from previous update!"
   fi
   if [ -e "/tmp/.updateInProgress" ] ; then
      pgrep -F /tmp/.updateInProgress >/dev/null 2>/dev/null
      if [ $? -eq 0 ] ; then
        exit_err "Another update is in progress!"
      fi
   fi
   echo "$$" > /tmp/.updateInProgress
}

touch_reboot()
{
   rm /tmp/.updateInProgress
   touch /tmp/.rebootRequired
}

require_root()
{
  if [ `id -u` != "0" ] ; then exit_err "Must be run as root!" ; fi
}

if [ `id -u` = "0" ] ; then
  echo "" > $LOGOUT
fi

if [ "`id -u`" = "0" ] ; then
  # Make the installed directory for this version
  if [ ! -d "${INSDIR}/${SYSVER}" ] ; then mkdir -p ${INSDIR}/${SYSVER} ; fi

  # Make the ignore directory for this version
  if [ ! -d "${IGNDIR}/${SYSVER}" ] ; then mkdir -p ${IGNDIR}/${SYSVER} ; fi
fi

if [ $# -eq 0 ] ; then
   show_usage
   exit 1
fi


while [ $# -gt 0 ] ; do

   case $1 in
	  autobe) require_root
		  do_auto_be ;;
	   check) do_fbsdcheck
		  get_update_file
                  do_check
		  exit $?
		  break
                  ;;
        branches) require_root
		  get_update_file
                  list_branches ; break ;;
        chbranch) require_root
		  get_update_file
                  do_branch "${2}"
		  exit 0
                  break
                  ;;
	pkgcheck) checkup_pkgs
		  exit $?
                  break
                  ;;
	syncconf) require_root
		  sync_pkgconf ; break ;;
       confcheck) check_pkgconf ; break ;;
       pkgupdate) require_root
		  update_pkgs_only "$2"
		  exit 0
                  break
                  ;;
  fbsdupdatepkgs) require_root
		  update_freebsd "pkgs"
		  exit 0
                  break
                  ;;
      fbsdupdate) require_root
		  update_freebsd ""
		  exit 0
                  break
                  ;;
 	 install) require_root
		  get_update_file
                  do_install "${2}"
		  exit 0
                  break
                  ;;
            cron) require_root
                  waittime=$(jot -r 1 1 3600)
                  sleep $waittime
                  do_fbsdcheck
                  get_update_file
                  do_check
                  checkup_pkgs ; break ;;
	*) show_usage ;;
   esac
   shift
done

exit 0
